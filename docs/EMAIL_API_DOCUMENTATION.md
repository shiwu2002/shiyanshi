# 后端邮箱逻辑接口说明文档

## 概述

本文档专门描述实验室预约管理系统中后端邮箱功能的核心逻辑接口。后端专注于邮箱验证的逻辑处理，包括验证码生成、验证、邮件发送等核心功能，所有前端页面展示由前端负责构建。

## 后端职责范围

- ✅ **后端负责**: 邮箱验证逻辑、验证码生成与验证、邮件发送、数据存储
- ❌ **后端不负责**: 前端页面展示、用户界面交互、页面跳转逻辑

## 技术架构

- **后端框架**: Spring Boot 3.x
- **邮件服务**: Spring Mail（纯邮件发送，无前端模板依赖）
- **缓存存储**: Redis（存储验证码和验证token）
- **安全机制**: JWT认证 + 验证码验证
- **API风格**: RESTful API（纯JSON数据交互）

## 后端邮箱逻辑服务类

### 1. EmailService（邮箱逻辑服务类）

#### 核心逻辑方法：

1. **sendRegisterVerifyEmail(String email, String username)**
   - **功能**: 发送注册验证邮件（逻辑处理）
   - **后端逻辑**: 
     - 生成UUID token，存储到Redis（30分钟有效）
     - 构建验证链接URL（纯后端逻辑，前端负责页面跳转）
     - 发送验证邮件
   - **数据交互**: 后端返回是否发送成功，前端负责链接点击后的页面展示

2. **sendVerificationCode(String email, String purpose)**
   - **功能**: 发送验证码邮件（逻辑处理）
   - **后端逻辑**:
     - 生成随机验证码，存储到Redis
     - 发送包含验证码的邮件
     - 验证码验证由后端完成，前端只负责输入框展示
   - **支持用途**: register（注册）、reset-password（重置密码）、bind-email（绑定邮箱）

3. **verifyCode(String email, String code)**
   - **功能**: 验证码验证逻辑
   - **后端逻辑**: 检查Redis中验证码，验证成功后删除，返回验证结果
   - **前端交互**: 前端根据验证结果展示相应页面

4. **verifyEmailToken(String token)**
   - **功能**: 邮箱验证token验证逻辑
   - **后端逻辑**: 检查Redis中token，返回验证状态
   - **前端交互**: 前端根据验证结果跳转到成功/失败页面

5. **预约相关通知邮件方法**
   - **功能**: 发送各类通知邮件（纯后端逻辑）
   - **特点**: 后端只负责邮件发送逻辑，不涉及前端页面展示

#### 后端逻辑配置参数：
```properties
# 邮箱服务配置（纯后端逻辑）
system.email.from=发件人邮箱
system.email.from-name=发件人名称
system.base-url=系统基础URL（用于构建验证链接）
verification.code.expire-minutes=验证码有效期（分钟）
verification.code.length=验证码长度
```

## 后端邮箱逻辑API接口

### 1. 发送注册验证邮件（后端逻辑接口）

**接口**: `POST /api/user/send-register-email`

**功能**: 邮箱验证逻辑处理（后端只负责逻辑，前端负责页面）

**后端逻辑处理**:
```json
// 请求参数（纯数据）
{
  "email": "user@example.com",
  "username": "用户名（可选）"
}

// 响应结果（纯状态）
{
  "code": 200,
  "message": "验证邮件已发送，请查收",
  "data": null
}
```

**后端核心逻辑**:
1. ✅ 邮箱格式验证和空值检查
2. ✅ 邮箱是否已被注册检查
3. ✅ 调用EmailService发送验证邮件
4. ✅ 生成验证token并存储到Redis

**前端职责**:
- 前端负责邮件发送按钮的UI展示
- 前端负责发送成功/失败的状态展示
- 前端负责验证链接点击后的页面跳转

---

### 2. 验证邮箱注册token（后端逻辑接口）

**接口**: `GET /api/user/verify-email`

**功能**: token验证逻辑处理（后端验证，前端展示结果）

**后端逻辑处理**:
```json
// 响应结果（验证状态）
{
  "code": 200,
  "message": "邮箱验证成功",
  "data": null
}
```

**后端核心逻辑**:
1. ✅ 验证token有效性（Redis检查）
2. ✅ 更新用户邮箱验证状态
3. ✅ 返回验证结果状态

**前端职责**:
- 前端根据验证结果展示成功/失败页面
- 前端负责页面跳转和用户引导

---

### 3. 发送验证码邮件（后端逻辑接口）

**接口**: `POST /api/user/send-code`

**功能**: 验证码发送逻辑处理（后端数据验证，前端展示）

**后端逻辑处理**:
```json
// 请求参数（用途标识）
{
  "email": "user@example.com",
  "purpose": "register | reset-password | bind-email | verify"
}

// 响应结果（发送状态）
{
  "code": 200,
  "message": "验证码已发送，请查收邮件",
  "data": null
}
```

**后端核心逻辑**:
1. ✅ 邮箱格式验证和空值检查
2. ✅ 根据用途检查邮箱业务状态
3. ✅ 调用EmailService生成并发送验证码
4. ✅ 验证码存储到Redis，设置有效期

**前端职责**:
- 前端负责验证码输入框的UI展示
- 前端负责倒计时和重新发送逻辑
- 前端负责发送状态的用户反馈

---

### 4. 验证验证码（后端逻辑接口）

**接口**: `POST /api/user/verify-code`

**功能**: 验证码验证逻辑处理（后端验证，前端展示结果）

**后端逻辑处理**:
```json
// 请求参数（验证数据）
{
  "email": "user@example.com",
  "code": "123456"
}

// 响应结果（验证状态）
{
  "code": 200,
  "message": "验证成功",
  "data": null
}
```

**后端核心逻辑**:
1. ✅ 邮箱和验证码非空验证
2. ✅ 调用EmailService验证码验证逻辑
3. ✅ 验证成功后删除Redis中的验证码
4. ✅ 返回验证结果状态

**前端职责**:
- 前端根据验证结果展示成功/失败提示
- 前端负责验证成功后的页面跳转

---

### 5. 通过邮箱验证码重置密码（后端逻辑接口）

**接口**: `POST /api/user/reset-password-by-email`

**功能**: 密码重置逻辑处理（后端验证和数据库操作）

**后端逻辑处理**:
```json
// 请求参数（重置数据）
{
  "email": "user@example.com",
  "code": "123456",
  "newPassword": "newPassword123"
}

// 响应结果（重置状态）
{
  "code": 200,
  "message": "密码重置成功",
  "data": null
}
```

**后端核心逻辑**:
1. ✅ 所有参数非空验证
2. ✅ 验证码有效性验证
3. ✅ 调用UserService重置密码密码
4. ✅ 密码加密存储到数据库

**前端职责**:
- 前端负责密码重置页面的UI展示
- 前端负责表单验证和用户体验
- 前端负责重置成功后的登录跳转

---

### 6. 绑定邮箱（后端逻辑接口）

**接口**: `POST /api/user/bind-email`

**功能**: 邮箱绑定逻辑处理（后端数据验证和存储）

**后端逻辑处理**:
```json
// 请求参数（绑定数据）
{
  "userId": 1,
  "email": "user@example.com",
  "code": "123456"
}

// 响应结果（绑定状态）
{
  "code": 200,
  "message": "邮箱绑定成功",
  "data": null
}
```

**后端核心逻辑**:
1. ✅ 所有参数非空验证
2. ✅ 邮箱是否已被其他用户使用的检查
3. ✅ 验证码有效性验证
4. ✅ 调用UserService绑定邮箱到用户

**前端职责**:
- 前端负责邮箱绑定页面的UI展示
- 前端负责发送验证码和表单验证
- 前端负责绑定成功后的状态反馈

---

### 7. 重新发送邮箱验证邮件（后端逻辑接口）

**接口**: `POST /api/user/resend-verify-email`

**功能**: 重新发送验证邮件逻辑处理

**后端逻辑处理**:
```json
// 请求参数（用户标识）
{
  "userId": 1
}

// 响应结果（发送状态）
{
  "code": 200,
  "message": "验证邮件已重新发送",
  "data": null
}
```

**后端核心逻辑**:
1. ✅ 用户存在性验证
2. ✅ 用户邮箱设置状态检查
3. ✅ 邮箱验证状态检查
4. ✅ 调用EmailService重新发送验证邮件

**前端职责**:
- 前端负责重新发送按钮的UI展示
- 前端负责发送间隔控制和状态提示
- 前端负责用户引导和操作反馈

## 后端邮件内容生成逻辑

### 邮件内容生成机制
- **模板引擎**: Thymeleaf（后端模板渲染）
- **数据变量**: 后端逻辑处理生成的动态数据
- **邮件内容**: 纯HTML邮件内容，由后端生成

### 核心邮件类型
1. **注册验证邮件**: 包含验证链接，由后端生成唯一token
2. **验证码邮件**: 包含随机验证码，后端生成并存储
3. **通知类邮件**: 预约状态变更通知，后端根据业务逻辑生成

### 后端职责
- ✅ 邮件内容的数据准备和模板渲染
- ✅ 验证链接和验证码的生成
- ✅ 邮件发送队列管理
- ❌ 邮件样式和前端展示（由邮件客户端负责）

## 后端安全逻辑机制

### 1. 验证码安全逻辑
- **生成逻辑**: 随机数生成，长度可配置
- **存储逻辑**: Redis存储，设置有效期
- **验证逻辑**: 验证成功后立即删除，防止复用
- **用途隔离**: 不同业务场景使用不同用途标识

### 2. Token安全逻辑
- **生成逻辑**: UUID唯一标识生成
- **存储逻辑**: Redis存储，30分钟有效期
- **验证逻辑**: 一次性验证，验证后删除
- **防重放**: 防止token重复使用

### 3. 邮箱验证逻辑
- **注册验证**: 强制邮箱验证流程
- **绑定验证**: 验证码验证机制
- **防滥用**: 邮箱唯一性检查和频率控制

## 后端错误处理逻辑

### 统一响应格式
```java
public class Result<T> {
    private Integer code;    // 状态码：200成功，400客户端错误，500服务器错误
    private String message;  // 提示信息（后端逻辑错误描述）
    private T data;          // 返回数据（逻辑处理结果）
}
```

### 错误类型处理
1. **参数验证错误** (400): 请求参数不符合业务逻辑要求
2. **业务逻辑错误** (400): 邮箱已注册、验证码错误等业务限制
3. **系统错误** (500): 邮件发送失败、Redis连接异常等系统问题
4. **权限错误** (403): 接口访问权限不足

### 后端职责
- ✅ 业务逻辑错误的准确识别和分类
- ✅ 错误信息的清晰描述（供前端展示）
- ✅ 异常情况的正确处理和日志记录

## 后端业务逻辑流程

### 用户注册逻辑流程
1. **邮箱验证请求**: `/send-register-email` → 后端生成token并发送邮件
2. **邮箱验证确认**: `/verify-email` → 后端验证token并更新状态
3. **用户注册完成**: `/register` → 后端创建用户记录

### 密码重置逻辑流程
1. **验证码请求**: `/send-code` (purpose=reset-password) → 后端发送验证码
2. **验证码验证**: `/verify-code` → 后端验证验证码
3. **密码重置**: `/reset-password-by-email` → 后端更新密码

### 邮箱绑定逻辑流程
1. **绑定验证码请求**: `/send-code` (purpose=bind-email) → 后端发送验证码
2. **验证码验证**: `/verify-code` → 后端验证验证码
3. **邮箱绑定**: `/bind-email` → 后端绑定邮箱到用户

### 后端核心关注点
- ✅ 每个步骤的业务逻辑验证
- ✅ 数据一致性和完整性保证
- ✅ 安全验证和权限控制
- ❌ 页面跳转和用户界面交互

## 后端逻辑配置说明

### 邮件服务配置（后端逻辑依赖）
```properties
# SMTP服务器配置（邮件发送逻辑）
spring.mail.host=smtp.example.com
spring.mail.port=587
spring.mail.username=your-email@example.com
spring.mail.password=your-password
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

# 系统逻辑配置
system.email.from=your-email@example.com          # 发件人邮箱（逻辑标识）
system.email.from-name=实验室预约系统             # 发件人名称（逻辑标识）
system.base-url=http://localhost:8080             # 系统基础URL（用于逻辑链接生成）

# 验证码逻辑配置
verification.code.expire-minutes=10               # 验证码有效期（逻辑控制）
verification.code.length=6                        # 验证码长度（逻辑生成）

# Redis缓存配置（逻辑数据存储）
spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.data.redis.database=0
```

### 配置项逻辑说明
1. **邮件配置**: 邮件发送服务的连接和认证逻辑
2. **系统配置**: 业务逻辑中需要的系统参数
3. **验证码配置**: 验证码生成和验证的逻辑参数
4. **Redis配置**: 临时数据存储的逻辑依赖

## 后端逻辑注意事项

### 逻辑依赖项
1. **邮件服务依赖**: SMTP服务器必须正确配置，否则邮件发送逻辑失败
2. **Redis服务依赖**: 验证码和token存储逻辑依赖Redis正常运行
3. **数据库依赖**: 用户数据和邮箱状态存储依赖数据库连接

### 逻辑安全考虑
1. **验证码频率控制**: 同一邮箱请求频率应有逻辑限制（建议实现）
2. **HTTPS安全**: 生产环境应使用HTTPS，保护验证数据传输
3. **密码安全**: 密码重置逻辑应包含强度验证和加密存储

### 逻辑扩展性
1. **邮件模板管理**: 邮件内容模板应支持动态配置
2. **验证码策略**: 验证码生成和验证策略应可配置
3. **错误处理**: 错误处理逻辑应支持国际化扩展

### 前后端分离原则
- ✅ 后端只提供数据接口和业务逻辑
- ✅ 所有用户界面和交互由前端负责
- ✅ 接口返回纯数据，不包含任何展示逻辑

---

*文档版本：1.0*
*最后更新：2026年1月14日*
*维护者：系统开发团队*
